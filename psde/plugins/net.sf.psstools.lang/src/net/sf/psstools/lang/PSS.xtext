// grammar net.sf.psstools.lang.PSS // with org.eclipse.xtext.common.Terminals
grammar net.sf.psstools.lang.PSS hidden(WS, ML_COMMENT, SL_COMMENT)
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate pSS "http://www.sf.net/psstools/lang/PSS"

Model:
	root+=portable_stimulus_description*;

portable_stimulus_description: 
	graph_declaration | 
	struct_declaration |
	interface_declaration |
	data_declaration |
<<<<<<< HEAD
	typedef_declaration |
	bins_declaration  /* |
	 * 	include_statement |

=======
	typedef_declaration
	/* |
	include_statement |
	bins_declaration |
>>>>>>> refs/remotes/upstream/master
	package_declaration */
;

// graph_or_struct_declaration and graph_struct_if_declaration are placeholders
// to help the language infrastructure understand that structs can only extend
// from structs, while graphs can extend from either a struct or a graph
graph_or_struct_declaration:
	graph_declaration|struct_declaration
;

graph_struct_ifc_declaration:
	graph_declaration|struct_declaration|interface_declaration
;


graph_declaration:
	'graph' name=graph_identifier 
		(
			'(' 
				(ports+=port_declaration (',' ports+=port_declaration)*)? 
			')'
		)?
		('extends' super=[graph_or_struct_declaration|graph_or_struct_identifier])? '{'
		body+=graph_body_item*
	'}'
;

port_declaration:
	('export')? ifc_type=[interface_declaration|interface_identifier] name=port_identifier
;

struct_declaration:
	'struct' name=identifier ('extends' super=[struct_declaration|struct_identifier])? '{'
	body+=struct_body_item*
	'}'
;

struct_body_item:
	constraint_declaration     |
	('rand')? data_declaration |
	typedef_declaration        |
	bin_or_scheme_declaration
;

graph_body_item:
	overrides_declaration  		|	
	constraint_declaration 		|
	('rand')? data_declaration 	|
<<<<<<< HEAD
	bin_or_scheme_declaration      |
=======
>>>>>>> refs/remotes/upstream/master
	typedef_declaration 		|
	symbol_declaration 			|
	symbol_definition 			|
	interface_action_definition	
;

symbol_definition:
	symbol_name=identifier ':=' body_items+=rule_production 
;

interface_action_definition:
	action=interface_action_id '(' parameters=action_portlist ')' ':=' '{' body_items+=graph_body_item* '}' 
;

/********************************************************************
 * Rule productions
 */
rule_production: 
	rule_stmt_or_block
;

rule_stmt_or_block:
	rule_repeat_stmt | rule_stmt_alt_parallel_seq /*  | rule_if_production */
	;

	
rule_stmt_alt_parallel_seq:
	rule_stmt_primary ({alt_stmt.left=current} '|' right=rule_stmt_primary)*
;

rule_stmt_primary:
	rule_stmt_parallel_alt ';' |
	'{' {rule_stmt_primary} stmt_list+=rule_stmt_or_block* '}'
;

rule_stmt_parallel_alt:
	rule_stmt_parallel ({stmt_alt.left=current} '|' right=rule_stmt_parallel)*
;

rule_stmt_parallel:
	rule_sequence ({rule_stmt_parallel.left=current} '&' right=rule_sequence)*	
;

rule_sequence:
	items+=rule_seq_item (',' items+=rule_seq_item)*
;

rule_seq_item:
	action=interface_action_id '(' action_params=parameter_list ')' |
	param=identifier '=' rhs=hierarchical_id |
	item=identifier (with_clause=rule_with_clause)?
;

rule_with_clause:
	{rule_with_clause} 'with' '{' body+=constraint_body_item* '}'
;

parameter_list:
	parameters+=hierarchical_id (',' parameters+=hierarchical_id)*
;

rule_repeat_stmt:
	'repeat' ('(' expr=expression ')')? stmt=rule_stmt_or_block 
;

//rule_if_production:
//	'if' constraint_block 
//;

/********************************************************************
 * Overrides
 */
 
overrides_declaration:
	{overides_declaration} 'override' '{' overrides+=override_stmt* '}'
;

override_stmt:
	type_override | instance_override
;

type_override:
	'type' src=identifier 'with' dest=identifier ';'
;

instance_override:
	'instance' src=hierarchical_id 'with' dest=identifier ';'
;

/********************************************************************
 * Data Declarations
 */
data_declaration:
	data_type instances+=data_instantiation (',' instances+=data_instantiation)* ';' 
;

data_instantiation:
	name=identifier ('(' portmap=graph_interface_portmap_list ')')?
;

graph_interface_portmap_list:
	{graph_interface_portmap_list} (maps+=graph_interface_portmap (',' maps+=graph_interface_portmap)*)?
;

graph_interface_portmap:
	'.' portname=identifier '(' connected_name=hierarchical_id ')'
;

data_type:
	integer_type |
	enum_type |
	user_defined_type
;

user_defined_type:
	typename=identifier /* TODO: parameterization */
//	graph_type|struct_type|typedef_type=[typedef_declaration]
;

typedef_declaration:
 	'typedef' type=data_type type_identifier=identifier ';' 
;
  
enum_type:
  	'enum' (data_type = integer_type)? '{' 
  		items+=identifier (',' items+=identifier)*
  		'}' 
  ;

integer_type:
	('signed'|'unsigned')? atom_type=integer_atom_type ('[' lhs=expression ':' rhs=expression ']')? (inside=type_inside_clause)?
; 

integer_atom_type:
	'int'|'bit'
;

type_inside_clause:
	'inside' '{' domain=open_range_list '}'
;

open_range_list:
	ranges+=open_range_value (',' ranges+=open_range_value)*
;

open_range_value:
	lhs=expression | '[' range=range_expr ']'
;

range_expr:
	'[' lhs=expression (':'|'..') rhs=expression ']'
;

 /********************************************************************
 * Constraints
 */
constraint_declaration:
	'constraint' name=identifier ('dynamic')? '{'
	body+=constraint_body_item*
	'}'
;

constraint_body_item:
	expression_or_dist_item |
	foreach_constraint_item |
	if_constraint_item
;

expression_or_dist_item:
	// TODO: dist item
	expression (('->' impl_constraint=constraint_set)|';')
;

if_constraint_item:
	'if' '(' if_expr=expression ')' true_case=constraint_set (=> 'else' false_set=constraint_set )? 
;

foreach_constraint_item:
	'foreach' '(' expr=expression ')' body=constraint_set
;

constraint_set:
	items+=constraint_body_item | items+=constraint_block
<<<<<<< HEAD
=======
;

constraint_block:
	'{' {constraint_set} items+=constraint_body_item* '}'
>>>>>>> refs/remotes/upstream/master
;

constraint_block:
	'{' {constraint_set} items+=constraint_body_item* '}'
;

/********************************************************************
 * Bins and Bin Schemes
 */
 bin_or_scheme_declaration:
 	bins_declaration       |
 	bin_scheme_declaration
 ;
 
 bins_declaration:
 	'bins' item=variable_identifier name=identifier bins=bin_specification ';'
 ;
 
 bin_specification:
 	items+=bin_specifier (items+=bin_specifier)* (bin_wildcard)?
 ;
 
 bin_specifier:
 	explicit_bin_value |
 	explicit_bin_range |
 	bin_range_divide   |
 	bin_range_size
 ;
 
 explicit_bin_value:
 	'[' constant ']'
 ;
 
 explicit_bin_range:
 	'[' low=constant '..' high=constant ']'
 ;
 
 bin_range_divide:
 	explicit_bin_range '/' div=constant
 ;
 
 bin_range_size:
 	explicit_bin_range ':' size=constant
 ;
 
 bin_wildcard:
 	'[*]'
 ;
 
 bin_scheme_declaration:
 	'bin_scheme' name=identifier '{' items+=bin_scheme_specifier (items+=bin_scheme_specifier)* '};'
 ;
 
 bin_scheme_specifier:
 	name=identifier (bin_identifier | spec=bin_specifier)
 ;
 
/********************************************************************
 * Expressions
 * 
 * Note: ANTLR doesn't support left-recursion in grammar productions.
 * Consequently, we can't say something like: 
 *   expression := expression '+' expression.
 * 
 * The expression grammar below is refactored to eliminate left 
 * recursion and properly implement operator precedence
 */
// TODO: should make special-purpose declaration 
constant_expression: expression;

expression: 
	condition_expr
	;
	
condition_expr returns expression:
	logical_or_expr ({condition_expr.left=current} '?' true_expr=logical_or_expr ':' false_expr=logical_or_expr)*
	; 

logical_or_expr returns expression:
	logical_and_expr ({logical_or_expr.left=current} '&&' right=logical_and_expr)*
;

logical_and_expr returns expression:
	binary_or_expr ({logical_and_expr.left=current} '||' right=binary_or_expr)*	
;

binary_or_expr returns expression:
	binary_xor_expr ({logical_or_expr.left=current} '|' right=binary_xor_expr)*
;

binary_xor_expr returns expression:
	binary_and_expr ({binary_xor_expr.left=current} '^' right=binary_and_expr)*
;

binary_and_expr returns expression:
	logical_equality_expr ({binary_and_expr.left=current} '&' right=logical_equality_expr)*
;

logical_equality_expr returns expression:
	logical_inequality_expr ({logical_equality_expr.left=current} op=eq_neq_op right=logical_inequality_expr)*
;

logical_inequality_expr returns expression:
	binary_shift_expr ({logical_inequality_expr.left=current} op=('<'|'<='|'>'|'>='|'inside') right=binary_shift_expr)*
;

binary_shift_expr returns expression:
	binary_add_sub_expr ({binary_shift_expr.left=current} op=shift_op right=binary_add_sub_expr)*
;

binary_add_sub_expr returns expression:
	binary_mul_div_mod_expr ({binary_add_sub_expr.left=current} op=add_sub_op right=binary_mul_div_mod_expr)*
;

binary_mul_div_mod_expr returns expression:
	binary_exp_expr ({binary_mul_div_mod_expr.left=current} op=mul_div_mod_op right=binary_exp_expr)*
;

binary_exp_expr returns expression:
	unary_expr ({binary_exp_expr.left=current} '**' right=unary_expr)*
;

unary_op: '+' | '-' | '!' | '~' | '&' | '|' | '^';

eq_neq_op: '==' | '!=';

shift_op: '<<' | '>>';

add_sub_op: '+' | '-';

mul_div_mod_op: '*' | '/' | '%';

unary_expr returns expression:
	(unary_op)? primary
;

primary returns expression:
	expr=literal | 
	'(' expr=expression ')' |
	expr=hierarchical_id ('[' lhs=expression (':' rhs=expression)? ']')?
;


interface_declaration:
	'interface' name=identifier ('extends' super=[interface_declaration])? '{'
	body+=interface_body_item*
	'}'
;

interface_body_item:
	action_declaration
;

action_declaration:
	'action' name=identifier '(' ports=action_portlist ')' ';'
;

action_portlist:
	{action_portlist} (ports+=action_port (',' ports+=action_port)*)?
;

action_port:
	(io_direction)? (type=data_type) name=identifier
;

io_direction:
	'input' | 'output' | 'inout'
;

graph_data_declaration:
	('rand')? type=[data_type] names+=identifier ('(' portmaps+=port_map (',' portmaps+=port_map)* ')')? 
		(',' names+=identifier ('(' portmaps+=port_map (',' portmaps+=port_map)* ')')?)* ';'
;

symbol_declaration:
	'symbol' decl_list+=symbol_decl_item (
		':=' inline_rule=rule_stmt_or_block |
		(',' decl_list+=symbol_decl_item)* ';'
	)
;

symbol_decl_item:
	name=identifier ('(' parameters=action_portlist ')')?
;

port_map:
	'.' port=identifier '(' map=hierarchical_id ')'
;



/********************************************************************
 * Identifiers, literals, etc
 */
 
graph_identifier: identifier;
struct_identifier: identifier;
interface_identifier: identifier;
graph_or_struct_identifier: identifier;
graph_struct_interface_identiifer: identifier;
port_identifier: identifier;
variable_identifier: identifier;
bin_identifier: identifier;
constant: literal | identifier;

identifier: ID;

hierarchical_id:
	value=identifier ('.' identifier)*
;

interface_action_id:
	ifc=identifier '.' action=identifier
;

interface_action_id:
	ifc=identifier '.' action=identifier
;

literal:
	value=INT
/*	  decimal_number 
	| octal_number
	| binary_number
	| hex_number */;
	
decimal_number:
	value=INT |
	(size)?	
;

size:
	value=INT
;

terminal INT returns ecore::EInt: ('0'..'9')+;
terminal WS			: (' '|'\t'|'\r'|'\n')+;
terminal ML_COMMENT	: '/*' -> '*/';
terminal SL_COMMENT 	: '//' !('\n'|'\r')* ('\r'? '\n')?;
terminal STRING	: 
			'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' 
		; 

terminal ID:
	'\\' !(' '|'\t'|'\r'|'\n')+ |
	('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
;

// terminal ANY_OTHER: .;
//graph_instance:
//	type=[graph_declaration] name=identifier ('(' portmaps+=port_map (',' portmaps+=port_map)* ')')? ';'
//;
