
// Per-IP control information
struct ip_info {
	rand bit is_write;
	rand int sz;
	
	constraint sz_c {
		sz inside {[1..4096]};
	}
}

// DMA channel configuration info
struct channel_alloc {
	rand int engine_id;
	rand int channel_id;
	
	constraint engine_c { engine_id == 0; }
	
	constraint channel_c { channel_id inside {[0..3]}; }
}

// Describes an operation across all three IP blocks
graph ip_operation(dma_alloc_ops ops) {
	ip_info ip1, ip2, ip3;
	channel_alloc ch1, ch2, ch3;
	int ip1_buf, ip2_buf, ip3_buf;
	
	constraint buf_c {
		ip1_buf inside {[0..2]};
		ip2_buf inside {[0..2]};
		ip3_buf inside {[0..2]};
		
		unique {ip1_buf, ip2_buf, ip3_buf};
	}
	
	constraint channel_alloc_c {
		unique {ch1, ch2, ch3};
	}
	
	ip_operation := {
		ip1, ip2, ip3;
		ch1, ch2, ch3;
		ip1_buf, ip2_buf, ip3_buf;

		fork {
			{
				// Setup IP1		
				ops.setup_ip1(ip1.is_write, ip1.sz);
				ops.setup_dma(ch1.engine, ch1.channel, ip1.is_write, 1, ip1_buf);
				
				// Wait for termination IRQ
				ops.wait_dma_irq(ch1.engine, ch1.channel);
			}
			
			{
				// Setup IP2
				ops.setup_ip2(ip2.is_write, ip2.sz);
				ops.setup_dma(ch2.engine, ch2.channel, ip2.is_write, 2, ip2_buf);
				
				// Wait for termination IRQ
				ops.wait_dma_irq(ch2.engine, ch2.channel);
			}
			
			{
				// Setup IP3
				ops.setup_ip3(ip3.is_write, ip3.sz);
				ops.setup_dma(ch3.engine, ch3.channel, ip3.is_write, 3, ip3_buf);
				
				// Wait for termination IRQ
				ops.wait_dma_irq(ch3.engine, ch3.channel);
			}
		}
	}	
}

graph dma_alloc_1(dma_alloc_ops ops) {
	ip_operation op1(ops), op2(ops);

	constraint test_c {
		// Write followed by read	
		op1.ip1.is_write == 1;
		op1.ip2.is_write == 1;
		op1.ip3.is_write == 1;
		op2.ip1.is_write == 0;
		op2.ip2.is_write == 0;
		op2.ip3.is_write == 0;

		// Use different channel assignments		
		unique {op1.ch1, op2.ch1};
		unique {op1.ch2, op2.ch2};
		unique {op1.ch3, op2.ch3};
	}

	
	dma_alloc_1 := {
		op1;
		op2;
	}	
	
}


