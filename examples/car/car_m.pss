
typedef enum {
	park,
	reverse,
	drive
} car_gear_e;

typedef enum {
	gas,
	brake
} car_pedal_e;

interface car_controls_if {
	action on_off(bit on);
	action gear(car_gear_e gear);
	action pedal(car_pedal_e pedal);
}

graph expects {
	typedef enum {
		forward,
		stop
	} car_dir_e;
	
	rand car_dir_e		car_dir;
	
	expects := car_dir;
}

graph inputs(car_controls_if car_ctrl) {
	rand bit 			on;
	rand car_gear_e		gear;
	rand car_pedal_e	pedal;
	
	constraint on_c {
		on dist {0, 1 := 10}
		// Must be stopped and in park in order to turn the car off
		if (!on) {
			gear == park;
			pedal == brake;
		}
	}
	
	inputs := {
		on, gear, pedal;
		// In order to turn the car off, we must first be 
		// in park
		if (!on) {
			car_ctrl.pedal(pedal);
			car_ctrl.gear(gear);
			car_ctrl.on_off(on);
		} else {
			// In order to put the car in gear, it must 
			// first be turned on
			car_ctrl.on_off(on);
			car_ctrl.gear(gear);
			car_ctrl.pedal(pedal);
		}
	}
}

graph test_top(car_controls_if car_ctrl) {
	expects	expects0;
	inputs	inputs0(car_ctrl);
	
	constraint inputs_expects_c {
		if (expects0.car_dir == expects.forward) {
			inputs0.on == 1;
			inputs0.gear == drive;
			inputs0.pedal == gas;
		} else {
//			inputs0.on == 1;
//			inputs0.gear == park;
//			inputs0.pedal == brake;
			// To be stopped, we either need to have the
			// brake on or be in park
			(inputs.pedal == brake || inputs.gear == park);
		}
	}
	
	test_top := repeat (20) {
		expects0;
		inputs0;
	}
}
