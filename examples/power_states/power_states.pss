enum domain_e {A, B, C};

// Coverspec captures goal of covering all pairs of 
// state of B
coverspec state1_state2_pairs(bit[0..3] state1, bit[0..3] state2) {
  state1_cp : coverpoint state1;
  state2_cp : coverpoint state2;
    	
  state1Xstate2 : cross state1_cp, state2_cp;
}

component foo {
}

component graphics_c {
    state struct power_state_s {
        rand bit[0..3] domain_A;
        
        rand bit[0..3] domain_B;
        
        rand bit[0..3] domain_C;
        
        constraint initial ->         
            domain_A == 0 &&
            domain_B == 0 &&
            domain_C == 0;
       
        // The level for switch A must be greater or equal to that of B
        constraint domain_A >= domain_B;
        
        // Domain C can be in a functional state only if B is off
        constraint domain_C != 0 -> domain_B == 0;
    };
    
    action power_transition_a {
        domain_e domain;
        
        rand int[-1,1] step;
        
        input power_state_s prev_state;
        output power_state_s next_state;
        
        constraint (domain == A) -> next_state.domain_A == prev_state.domain_A + step;
        constraint (domain != A) -> next_state.domain_A == prev_state.domain_A;
        
        constraint (domain == B) -> next_state.domain_B == prev_state.domain_B + step;
        constraint (domain != B) -> next_state.domain_B == prev_state.domain_B;
        
        constraint (domain == C) -> next_state.domain_C == prev_state.domain_C + step;
        constraint (domain != C) -> next_state.domain_C == prev_state.domain_C;
    };
    
    action power_state_observe_a {
        input power_state_s curr_state;    
    };
   

    // Get from a functional state of B to another functional 
    // state of B, while traversing full power on C in between.
    // This needs to be exercised for all pairs of start and
    // end states of B.
    action full_C_between_functional_Bs_a {
        rand bit[0..3] first_B_state, second_B_state;
        
        graph {
            power_state_observe_a a0;
            constraint a0.curr_state.domain_B == first_B_state;
            power_state_observe_a a1;
            constraint a1.curr_state.domain_C == 3;
            power_state_observe_a a2;
            constraint a2.curr_state.domain_B == second_B_state;
        };

        // Instance of coverspec to cause traversal of all states        
        state1_state2_pairs b_pairs(first_B_state, second_B_state);
    };
};


////////////////////////////////////////////////////
// integrator code
////////////////////////////////////////////////////

extend component DVE {
    graphics_c graphics1;
    graphics_c graphics2;
   
    // Exercise the cross product of end states for the two
    // graphics subsystems
    state1_state2_pairs g1_g2_pairs(
    	graphics1.full_C_between_functional_Bs_a.second_B_state,
    	graphics2.full_C_between_functional_Bs_a.second_B_state,
    );
};
