
// Actions have:
// - associated component type (DVE.cache_ops -- ie something that can run cache operations?)
//   - DVE.power_ops.proc2_power -- ie something that can power down proc2?
// - associated resource (proc_tag -- where this action should execute?)

// What is the difference between actions marked 'e' and 'a'?

struct cache_region_t {
	rand bit inside {[1..16]} num_of_lines;
}

typedef enum {
	proc1,
	proc2,
	proc3
} proc_tag;

typedef enum {
	L0,			// L0 is ON
	L1			// L1 is OFF
	
} power_state_t;

interface coherency_if {
	action alloc_cache_region(output cache_region_t out_region);
	action read_write_cache(input cache_region_t in_region, proc_tag proc);
}

interface power_if {
	action power_up(proc_tag proc, power_state_t prev, power_state_t next);
	action power_down(proc_tag proc, power_state_t prev, power_state_t next);
}

graph coherency_low_power(coherency_if c_if, power_if p_if) {
	cache_region_t		cache_region;
	
	coherency_low_power() := {
		c_if.alloc_cache_region(cache_region); // Don't think we need proc_tag here
		
		fork {
			{
			c_if.read_write_cache(cache_region, proc1);
			c_if.read_write_cache(cache_region, proc2);
			}
			c_if.read_write_cache(cache_region, proc3);
		}
		
		// Power down proc3 and proc2
		fork {
			p_if.power_down(proc2, L0, L1); // have proc2 power itself down -- proc_tag==proc2
			p_if.power_down(proc3, L0, L1); // have proc3 power itself down -- proc_tag==proc3
		}
		
		// Run more cache operations on proc1
		c_if.read_write_cache(cache_region, proc1);

		// Power up proc3, then proc2
		p_if.power_up(proc3, L1, L0); // have proc1 power up proc3 -- proc_tag==proc1
		p_if.power_up(proc2, L1, L0); // have proc1 power up proc3 -- proc_tag==proc1
		
		// Now, run more cache ops
		fork {
			c_if.read_write_cache(cache_region, proc1);
			c_if.read_write_cache(cache_region, proc2);
			c_if.read_write_cache(cache_region, proc3);
		}
		
	}
	
}
